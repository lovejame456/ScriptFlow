# M12.2 受控推进（Controlled Progression）实施总结

## 一句话目标

让 Writer"推进状态"，而不是"重新想象世界"。

## 核心机制

在 M12.1 NarrativeState 的基础上，引入状态变更提案（StateDelta）机制：

```
Writer 生成内容 + StateDelta (提案)
      ↓
Aligner 校验 StateDelta 合法性
      ↓ (PASS)
合并 StateDelta → NarrativeState
```

## M12.2 只做两件事

### ① Writer：只读 NarrativeState，输出"状态变更提案"

Writer 仍然写剧情，但额外输出一个 `StateDelta`（状态差分），不直接修改 NarrativeState。

示例：
```json
{
  "episode": {
    "title": "本集标题",
    "content": "完整剧本正文..."
  },
  "stateDelta": {
    "conflicts": {
      "immediate": { "status": "resolved" }
    },
    "characters": {
      "林风": { "status": "injured" }
    }
  }
}
```

Writer 不"改状态"，只"提议状态变化"。

### ② Aligner：校验 StateDelta 是否合法

Aligner 新增一组硬规则（不看文风）：

- ❌ 是否非法解锁冲突（跳过 immediate 直接 mid_term）
- ❌ 是否违反 worldRules.immutable
- ❌ 是否让角色"瞬移成长"（goal 未推进却完成）

通过 → 合并 StateDelta
失败 → FAIL（明确原因）

从这一刻起，Aligner 变成了状态守门员。

## 冲突解锁机制（M12.2 的核心）

在 M11 定义了三层冲突，现在第一次让它"动起来"：

| 冲突层级     | 初始状态   | 允许解锁条件              |
|------------|---------|----------------------|
| IMMEDIATE  | active  | EP1 内可 resolved     |
| MID_TERM   | locked  | immediate resolved 后  |
| END_GAME   | locked  | mid_term resolved 后   |

Aligner 负责校验，系统负责合并。

## 实施内容

### 1. 定义 StateDelta 类型（types.ts）

```typescript
export interface StateDelta {
  conflicts?: {
    immediate?: { status?: 'active' | 'resolved' };
    mid_term?: { status?: 'locked' | 'active' | 'resolved' };
    end_game?: { status?: 'locked' | 'active' | 'resolved' };
  };
  characters?: Record<string, {
    status?: 'unresolved' | 'injured' | 'compromised' | 'resolved';
  }>;
  worldRuleViolations?: string[];
}
```

### 2. Aligner 校验逻辑（alignerRunner.ts）

新增 `validateStateDelta` 函数，实现三条硬规则：

1. **冲突解锁顺序校验**：
   - immediate → mid_term：immediate 未解决前不能激活 mid_term
   - mid_term → end_game：mid_term 未解决前不能激活 end_game
   - 防止倒退：已 resolved 的冲突不能回退到 active

2. **角色状态合理性校验**：
   - 不允许直接从 unresolved 跳到 resolved
   - 建议路径：unresolved → injured/compromised → resolved

3. **世界观规则校验**：
   - worldRuleViolations 仅用于记录，不允许修改 immutable

### 3. StateDelta 合并逻辑（narrativeState.ts）

新增 `mergeStateDelta` 函数，实现状态合并：

```typescript
export function mergeStateDelta(
  currentState: NarrativeState,
  delta: StateDelta
): NarrativeState
```

仅在 Aligner PASS 后调用，合并逻辑：
- 更新冲突状态（immediate / mid_term / end_game）
- 更新角色状态（status 字段）
- 记录世界观违规（worldRules.violated）

### 4. Writer Prompt 改动（最小化）

在 `episode_writer_std.md` 中：

- 添加"状态变更提案（可选）"说明
- 在输出结构中添加可选的 `stateDelta` 字段

不重写 Writer，仅补充说明和字段。

### 5. 生成流程集成（episodeFlow.ts）

在 `generateEpisodeFast` 和 `rewriteDraftEpisode` 中：

- 解析 episodeObject.stateDelta
- 保存 Episode 时包含 stateDelta
- Aligner PASS 后，调用 `mergeStateDelta` 合并到 NarrativeState
- 更新 project.narrativeState

## 验收结果

### EP1 / EP2 状态演进示例

#### 初始态（M12.1 已生成）

```json
{
  "characters": {
    "林风": {
      "role": "PROTAGONIST",
      "goal": "找到失踪妹妹",
      "flaw": "冲动",
      "relationship": "与妹妹相依为命",
      "status": "unresolved"
    },
    "王霸": {
      "role": "ANTAGONIST",
      "goal": "掩盖非法交易",
      "flaw": "傲慢",
      "relationship": "压迫林风",
      "status": "unresolved"
    }
  },
  "conflicts": {
    "immediate": {
      "description": "王霸派人威胁林风交出证据",
      "status": "active"
    },
    "mid_term": {
      "description": "妹妹失踪背后的黑幕",
      "status": "locked"
    },
    "end_game": {
      "description": "与王霸的最终对决",
      "status": "locked"
    }
  },
  "worldRules": {
    "immutable": ["现代都市背景", "无超自然能力", "法律体系真实"],
    "violated": []
  },
  "phase": "EP1"
}
```

#### EP1 StateDelta 提案（合法）

```json
{
  "conflicts": {
    "immediate": { "status": "resolved" }  // EP1 结束时解决 immediate 冲突
  },
  "characters": {
    "林风": { "status": "injured" }  // EP1 受伤
  }
}
```

**Aligner 校验结果**：PASS

#### EP1 合并后状态

```json
{
  "conflicts": {
    "immediate": {
      "description": "...",
      "status": "resolved"  // ✅ 已解决
    },
    "mid_term": {
      "description": "...",
      "status": "locked"  // ⏸ 仍 locked
    },
    "end_game": {
      "description": "...",
      "status": "locked"  // ⏸ 仍 locked
    }
  },
  "characters": {
    "林风": {
      "status": "injured"  // ✅ 受伤
    },
    "王霸": {
      "status": "unresolved"
    }
  }
}
```

#### EP2 StateDelta 提案（合法）

```json
{
  "conflicts": {
    "mid_term": { "status": "active" }  // EP2 开始时解锁 mid_term
  },
  "characters": {
    "林风": { "status": "unresolved" }  // EP2 恢复
  }
}
```

**Aligner 校验结果**：PASS

#### EP2 合并后状态

```json
{
  "conflicts": {
    "immediate": {
      "description": "...",
      "status": "resolved"  // ✅ 保持 resolved
    },
    "mid_term": {
      "description": "...",
      "status": "active"  // ✅ 解锁成功
    },
    "end_game": {
      "description": "...",
      "status": "locked"  // ⏸ 仍 locked
    }
  },
  "characters": {
    "林风": {
      "status": "unresolved"  // ✅ 恢复
    }
  }
}
```

#### EP2 非法 StateDelta 示例（应该被 Aligner 拒绝）

```json
{
  "conflicts": {
    "end_game": { "status": "active" }  // ❌ 跳级解锁：mid_term 未解决
  }
}
```

**Aligner 校验结果**：
```json
{
  "passed": false,
  "severity": "FAIL",
  "issues": [
    {
      "code": "STATE_DELTA_INVALID",
      "message": "end_game 冲突不能在 mid_term 未解决前激活"
    }
  ],
  "editorNotes": ["P0级违规：状态变更提案不合法 - end_game 冲突不能在 mid_term 未解决前激活"]
}
```

## 验收清单

### ✅ M12.2 验收通过

1. **EP1**：
   - ✅ immediate 可 resolved
   - ✅ mid_term / end_game 仍 locked

2. **EP2**：
   - ✅ 不能直接动 end_game
   - ✅ immediate resolved 后才能解锁 mid_term

3. **任何一集**：
   - ✅ NarrativeState 只能通过合法 StateDelta 变化
   - ✅ E2E 不退化
   - ✅ 失败是结构性失败，不是"感觉不对"

### 测试用例覆盖

- ✅ EP1 有效 StateDelta 校验通过
- ✅ EP1 跳级解锁（mid_term）被拦截
- ✅ EP1 角色状态跳变被拦截
- ✅ EP2 有效 StateDelta 校验通过
- ✅ EP2 跳级解锁（end_game）被拦截
- ✅ 无 StateDelta 默认通过
- ✅ EP1 StateDelta 合并正确
- ✅ EP1 -> EP2 完整演进正确
- ✅ 世界观违规记录正确，immutable 未被修改

## 约束遵守

- ✅ 不重写 Writer，仅添加可选 stateDelta 字段
- ✅ 不修改现有 prompt 结构，仅补充说明
- ✅ NarrativeState 仍不直接参与 prompt
- ✅ 保持 PHASE1_ONLY / FULL_PIPELINE 语义不变
- ✅ 不影响正文生成质量

## 架构意义

M12.2 实现了"受控叙事引擎"的核心思想：

1. **Writer 不改状态**：Writer 专注写剧情，通过 stateDelta 提案变化
2. **Aligner 守门**：Aligner 从"风格检查"升级为"状态守门员"
3. **状态机推进**：NarrativeState 作为状态机，通过合法 Delta 推进
4. **可追溯**：每个集的状态变化都有明确来源（stateDelta）

从这一刻起，每一小步，都是系统能力的"永久解锁"。

## 文件修改清单

1. **types.ts**：
   - 新增 `StateDelta` 接口
   - 修改 `Episode` 接口，添加 `stateDelta?: StateDelta` 字段

2. **lib/ai/alignerRunner.ts**：
   - 新增 `validateStateDelta` 函数
   - 修改 `runAligner` 函数，添加 StateDelta 校验逻辑

3. **lib/ai/narrativeState.ts**：
   - 新增 `mergeStateDelta` 函数

4. **prompts/execution/episode_writer_std.md**：
   - 添加"状态变更提案（可选）"说明
   - 在输出结构中添加 `stateDelta` 字段

5. **lib/ai/episodeFlow.ts**：
   - 修改 `rewriteDraftEpisode`，在 Aligner PASS 后合并 stateDelta
   - 修改 `generateEpisodeFast`，保存 stateDelta 到 Episode

6. **test-m12-state-delta.ts**（新增）：
   - 完整的验收测试套件
   - 覆盖所有硬规则和合并逻辑

## 后续展望

M12.2 完成了"受控推进"的第一步，后续可以在此基础上扩展：

- 更细粒度的角色状态（情绪、认知变化）
- 冲突状态的中间态（部分解决、升级）
- 状态回滚机制（用于剧情分支探索）
- 状态可视化（让用户清晰看到叙事演进）

M12.2 奠定了"状态守门员"的基础，未来所有 Agent 的状态操作都必须通过 Aligner 校验。

