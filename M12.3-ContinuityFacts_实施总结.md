# M12.3 Continuity Facts（连续性事实层）实施总结

## 一句话目标

每集输出一份极短、可校验的"事实记忆"，供后续集引用，解决 EP2+ 忘事与矛盾问题。

## 实施原则

- 不塞 NarrativeState 进 prompt
- 不增加首屏阻塞
- 不改正文质量逻辑

## 实施内容

### 1. 类型定义（types.ts）

新增接口：

```typescript
/**
 * EpisodeFacts - 连续性事实层（M12.3）
 * 每集输出的极短、可校验的"事实记忆"，供后续集引用，解决忘事/矛盾
 */
export interface EpisodeFacts {
  events: string[];     // 关键事件
  reveals: string[];    // 揭示/秘密揭晓
  items: string[];      // 关键道具/线索
  injuries: string[];   // 角色受伤状态
  promises: string[];   // 承诺/誓言
}

/**
 * EpisodeFactsRecord - 连续性事实记录
 * 按集数索引保存的所有 facts
 */
export interface EpisodeFactsRecord {
  episodeIndex: number;
  facts: EpisodeFacts;
}
```

在 `Project` 接口中添加字段：

```typescript
episodeFactsHistory?: EpisodeFactsRecord[];  // M12.3: 连续性事实历史 (可选)
```

在 `Episode` 接口中添加字段：

```typescript
episodeFacts?: EpisodeFacts;  // M12.3: 连续性事实
```

**约束**：
- 每个分类最多 3 条
- 单条事实不超过 80 字符
- 总条数不超过 12 条（5 个分类 × 最多 3 条）

### 2. Prompt 修改（prompts/execution/episode_writer_std.md）

在输出结构中添加 `episodeFacts` 字段：

```json
{
  "episode": { ... },
  "sceneRoles": [...],
  "hook": "...",
  "memoryDelta": { ... },
  "stateDelta": { ... },
  "episodeFacts": {
    "events": [
      "主角在雨夜与反派发生第一次正面冲突",
      "主角发现自己的父亲并非病逝"
    ],
    "reveals": [
      "主角发现自己有特殊能力"
    ],
    "items": [
      "获得反派遗落的神秘手机"
    ],
    "injuries": [
      "主角右臂被划伤，轻伤"
    ],
    "promises": [
      "发誓一定要查清真相"
    ]
  }
}
```

在 Prompt 中添加约束说明：

- 每个分类最多 3 条
- 单条事实不超过 80 字符
- 必须是"具体主体 + 行动/变化"的句式
- 不得使用抽象情绪描述（如"很痛苦""很愤怒"）

### 3. Aligner 校验（lib/ai/alignerRunner.ts）

新增 `validateEpisodeFacts` 函数：

**结构校验**：
- 每个分类必须是数组
- 每个分类最多 3 条
- 单条事实不超过 80 字符

**一致性校验**（仅当 episodeIndex > 1）：
1. **伤情矛盾检测**：如果上集某角色有伤情，本集 events 中说该角色"完好""健康""痊愈"，但 injuries 中未提及该角色，则报错
2. **关键道具凭空出现**：如果上集没有某个道具，本集应该有"获得/发现/捡到"等动作（简化处理）
3. **揭示否认检测**：如果本集 events 中包含"否认""推翻""收回""错误""误会""不是"等关键词，则提示可能否认上集的揭示

在 `runAligner` 函数中集成校验：

```typescript
// ========= M12.3: EpisodeFacts 校验 =========
const episodeFacts = (episode as any).episodeFacts;
const previousFacts = project.episodeFactsHistory || [];

const factsValidation = validateEpisodeFacts({
  currentFacts: episodeFacts,
  previousFactsList: previousFacts,
  episodeIndex: pacingContext.episodeIndex
});

if (!factsValidation.valid) {
  return {
    passed: false,
    severity: "FAIL",
    issues: factsValidation.errors.map(err => ({
      code: "EPISODE_FACTS_INVALID",
      message: err
    })),
    editorNotes: [`P0级违规：连续性事实错误 - ${factsValidation.errors.join('、')}`]
  };
}
```

### 4. Facts 保存逻辑（lib/ai/episodeFlow.ts）

在 `rewriteDraftEpisode` 函数中：

```typescript
// ========= M12.3: 保存 episodeFacts =========
if (episodeObject.episodeFacts) {
  const newRecord = {
    episodeIndex,
    facts: episodeObject.episodeFacts
  };

  const currentHistory = project.episodeFactsHistory || [];
  await projectRepo.save(projectId, {
    episodeFactsHistory: [...currentHistory, newRecord]
  });

  console.log(`[rewriteDraftEpisode] EpisodeFacts saved for EP${episodeIndex}`);
}
```

在 `generateEpisodeFast` 函数中：

```typescript
const episode = {
  // ... 其他字段
  episodeFacts: episodeObject.episodeFacts,  // M12.3: 保存 episodeFacts
  // ...
};
```

### 5. Facts 引用逻辑（lib/ai/episodeFlow.ts）

在 `generateEpisodeFast` 和 `_generateOneEpisodeFull` 函数中，当生成 EP2+ 时，构建简短的 facts 引用注入到 prompt：

```typescript
// M12.3: 构建连续性事实引用（仅当 episodeIndex > 1）
if (episodeIndex > 1 && project.episodeFactsHistory && project.episodeFactsHistory.length > 0) {
  const recentFacts = project.episodeFactsHistory
    .filter(r => r.episodeIndex >= episodeIndex - 2)  // 最近 2 集
    .map(r => {
      const summaryParts: string[] = [];
      // 每个分类最多取 1 条，总长度不超过 100 字
      if (r.facts.events.length > 0) {
        summaryParts.push(r.facts.events[0]);
      }
      if (r.facts.reveals.length > 0) {
        summaryParts.push(r.facts.reveals[0]);
      }
      if (r.facts.items.length > 0) {
        summaryParts.push(r.facts.items[0]);
      }
      const summary = summaryParts.join('；');
      return `EP${r.episodeIndex}: ${summary}`;
    })
    .join('\n');

  if (recentFacts.length > 0) {
    promptInjection += `\n\n【最近剧集事实（必须遵守）】\n${recentFacts}`;
  }
}
```

## 修改文件清单

1. `types.ts` - 新增 `EpisodeFacts` 和 `EpisodeFactsRecord` 类型，修改 `Project` 和 `Episode` 接口
2. `prompts/execution/episode_writer_std.md` - 在输出结构中添加 `episodeFacts` 字段和约束说明
3. `lib/ai/alignerRunner.ts` - 新增 `validateEpisodeFacts` 函数，修改 `runAligner` 集成校验
4. `lib/ai/episodeFlow.ts` - 在保存 Episode 时保存 facts，生成下一集时读取 facts
5. `test-m12.3-episode-facts.ts` - 编写 EP1→EP2 连续性测试用例
6. `test-simple-injury-check.ts` - 简化版伤情矛盾检测测试

## 验收示例

### EP1 的 episodeFacts 示例（脱敏）

```json
{
  "episodeFacts": {
    "events": [
      "主角在雨夜与反派发生第一次正面冲突",
      "主角发现自己的父亲并非病逝"
    ],
    "reveals": [
      "主角发现自己有特殊能力"
    ],
    "items": [
      "获得反派遗落的神秘手机"
    ],
    "injuries": [
      "主角右臂被划伤，轻伤"
    ],
    "promises": [
      "发誓一定要查清真相"
    ]
  }
}
```

### EP2 如何引用并保持一致

在 EP2 的 facts 中：

- `injuries` 应该包含"主角右臂伤势未愈"或"主角右臂已恢复"（不能完全忽略）
- `items` 可以引用"使用神秘手机"（说明之前获得的手机还在）
- `events` 可以延续"继续调查父亲死因"

如果 EP2 的 facts 中出现"主角右臂完好且从未受过伤"，Aligner 应该报错：

**角色 主角右臂被划伤，轻伤 伤情矛盾：上集主角右臂被划伤，轻伤，本集状态完好**

## 测试结果

### 测试 1: EP1 → EP2 正常连续性

**输入**：
- EP1 facts: 主角在雨夜与反派发生第一次正面冲突，主角发现自己有特殊能力，获得反派遗落的神秘手机，主角右臂被划伤轻伤
- EP2 facts: 主角使用神秘手机查询父亲信息，继续调查父亲死因，使用神秘手机，主角右臂伤势未愈

**结果**：✓ 通过 - EP2 facts 与 EP1 facts 保持一致

### 测试 2: EP1 → EP2 矛盾检测（伤情）

**输入**：
- EP1 facts: 主角在雨夜与反派发生第一次正面冲突，主角右臂被划伤，重伤
- EP2 facts: 主角身体健康，状态完好（injuries 中未提及主角）

**结果**：✓ 通过 - 成功检测到伤情矛盾

**错误信息**：`角色 主角右臂被划伤，重伤 伤情矛盾：上集主角右臂被划伤，重伤，本集状态完好`

### 测试 3: EP1 → EP2 揭示否认检测

**输入**：
- EP1 facts: 主角发现自己的父亲并非病逝，而是被害
- EP2 facts: 主角否认父亲被害的说法，主角推翻之前的结论

**结果**：✓ 通过 - 成功检测到揭示否认

**错误信息**：`本集可能否认或推翻上集揭示: 主角发现自己的父亲并非病逝，而是被害`

### 测试 4: Facts 结构约束

**测试 4.1**: ✓ 通过 - 成功检测到分类超过 3 条限制
**测试 4.2**: ✓ 通过 - 成功检测到单条事实超过 80 字符
**测试 4.3**: ✓ 通过 - 正常 facts 结构通过校验

### 测试 5: 伤情矛盾检测（简化版）

**测试 5.1**: ✓ 通过 - 成功检测到伤情矛盾
**测试 5.2**: ✓ 通过 - 伤情一致（正常）通过校验

## 与 M12.2 的协作

M12.3 与 M12.2（推进合法性）形成了完整的叙事控制系统：

- **M12.2（StateDelta）**：控制冲突解锁顺序（immediate → mid_term → end_game）和角色状态变化
- **M12.3（EpisodeFacts）**：控制事实连续性（伤情、道具、揭示）

两者通过 Aligner 的双重校验，确保剧集既"推进合法"，又"连续一致"。

## 系统能力提升

M12.3 完成后，系统拥有：

1. **推进合法性**（M12.2）
   - 冲突解锁顺序校验
   - 角色状态变化合理性校验
   - 世界规则违规记录

2. **连续性记忆**（M12.3）
   - 事实结构约束（长度、数量）
   - 伤情一致性校验
   - 道具连续性校验
   - 揭示否认检测

3. **状态 + 事实驱动质量**
   - 不依赖 prompt 大段塞入
   - 通过结构化的事实记忆指导生成
   - 可精确拦截矛盾和忘事

## 遵循原则

- ✅ 不塞 NarrativeState 进 prompt
  - NarrativeState 仅用于 Aligner 校验，不直接提供给 Writer
  - Facts 以短条目形式注入 prompt，长度可控

- ✅ 不增加首屏阻塞
  - Facts 保存是后台异步操作
  - Aligner 校验在增强阶段执行，不阻塞首屏

- ✅ 不改正文质量逻辑
  - Facts 不参与正文生成质量检查
  - 仅用于连续性校验

## 后续改进方向

1. **事实查询能力**：增强 Aligner，支持复杂查询（如"查角色 A 在最近 5 集的所有道具"）
2. **事实可视化**：在前端展示 facts 历史，方便人工核查
3. **事实修复工具**：提供工具批量修复 facts 矛盾（如批量更新伤情）
4. **事实优先级**：给不同类型的 facts 设置优先级（如揭示 > 道具 > 承诺）
5. **跨项目事实继承**：支持从其他项目导入 facts（系列作品复用）

## 总结

M12.3 Continuity Facts（连续性事实层）已成功实施，实现了：

- ✓ EpisodeFacts 类型定义（5 个分类，约束清晰）
- ✓ Prompt 要求 Writer 输出结构化 facts
- ✓ Aligner 结构和一致性双重校验
- ✓ Facts 保存到项目历史
- ✓ EP2+ 读取并遵守上一集 facts
- ✓ 全面的测试覆盖（连续性、矛盾、结构）

系统现在同时拥有**推进合法性**（M12.2）和**连续性记忆**（M12.3），为进入真正的"质量提升期"奠定了坚实基础。

